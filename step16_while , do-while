Step16：while / do-while

1) 基本の書き方（例文コード）

A. while の基本（step16_while_basic.php）

<?php
// 1から5までを表示し、その合計も計算する例
$count = 1;      / 初期化
$sum   = 0;      / 累積用

while ($count <= 5) {     / 繰り返し条件
    echo $count . "\n";   / 処理
    $sum += $count;       / 状態の更新
    $count++;             / インクリメント（これを忘れると無限ループ）
}

echo "合計: " . $sum . "\n";  / 出力

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

B. do-while の基本（step16_do_while_basic.php）
<?php
// do-while は条件判定が「後」なので最低1回は必ず実行される
$tries = 0;
do {
    echo "少なくとも1回は表示されます\n";
    $tries++;
} while ($tries < 0); / ここは最初からfalseだが、1回は実行される

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

C. break / continue の使い所（step16_while_break_continue.php）
<?php
// 偶数だけを加算し、合計が100を超えたら break で終了する例
$i   = 1;
$sum = 0;

while (true) {
    if ($i % 2 !== 0) {        // 奇数ならスキップ
        $i++;
        continue;
    }
    $sum += $i;
    echo "加算: {$i} / 合計: {$sum}\n";

    if ($sum > 100) {          // しきい値を超えたら終了
        echo "しきい値を超えたので終了\n";
        break;
    }
    $i++;
}

参考：上の「偶数だけ合計 → 100超で終了」の最後は 20 を加算した時点で合計 110 になり終了します（Pythonで検算済）。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

2) なぜ重要か（意味・メリット）

while：回数が決まっていない繰り返し（「条件が成り立つ限り続けたい」処理）に適します。ファイル読み込み、APIポーリング、待機処理など。

do-while：最低1回は必ず実行したい場面に有効。メニュー表示→入力のような処理や、初回実行で状態を作ってから判定するケースに向きます。

break/continue：ループの中断やスキップを明確に記述でき、早期終了や条件ごとの枝分かれを簡潔に実装できます。

実務では、**「条件駆動のループ」**を正しく設計できると、無限ループやオフバイワンを避け、保守性の高いロジックになります。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

疑問：APIポーリング、待機処理とは？条件駆動のループとは？オフバイワンとは？

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

1. APIポーリングとは

意味：「サーバーに新しい情報がないか、一定間隔で繰り返し問い合わせる処理」

例：
天気予報アプリが、10分おきに気象APIにアクセスして新しい天気データがあるか確認する。
チャットアプリが、新しいメッセージが来ていないか数秒ごとにサーバーをチェックする。

メリット：リアルタイムに近い更新ができる。

デメリット：無駄なリクエストが多くなりやすく、サーバーやネットワークに負荷がかかる。
（そのため最近は「WebSocket」や「サーバーからの通知」などの方法も使われます）

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

2. 待機処理とは

意味：ある条件が満たされるまで処理を「繰り返し待つ」こと。

例：

ファイルがアップロード完了するまで待つ。

ユーザーの入力があるまで処理を止めて待つ。

外部システムが応答を返すまでループで待機する。

実務での使い方：

whileループに「条件が整うまで sleep する処理」を書くことが多いです。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

3. 条件駆動のループとは

意味：「繰り返す回数をあらかじめ決めるのではなく、条件が成り立つ限り処理を続けるループ」

典型例：while文、do-while文

例：

$count = 0;
while ($count < 10) { // 条件駆動：$countが10未満なら続ける
    echo $count . "\n";
    $count++;
}


for文は「回数が決まっている繰り返し」に向いていますが、
whileは「いつ終わるか分からないが条件で判断する繰り返し」に向いています。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

4. オフバイワン（off-by-one error）とは

意味：「ループや配列処理で、1回多い / 1回少ない というズレが生じる典型的なバグ」

例：

$array = ["A", "B", "C"];
for ($i = 0; $i <= count($array); $i++) {
    echo $array[$i] . "\n"; 
}


このコードは <= のせいで 最後の添字3 にアクセスしてしまいエラーになる。
正しくは < を使う必要があります。

実務での被害：

配列の範囲外アクセス

無限ループや1回足りない繰り返し

防止策：
インデックスや条件を紙に書いて追う
テストデータを用意して確認する
IDEや静的解析で検出する
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
✅ まとめると
APIポーリング：一定間隔でサーバーに「新しい情報ありますか？」と聞き続ける
待機処理：条件が整うまで処理を繰り返して「待つ」
条件駆動のループ：回数ではなく「条件」が成り立つ限り続けるループ（while系）
オフバイワン：ループ条件が1回ずれて「多すぎ/少なすぎ」になる典型的なバグ
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

問題1（whileの基礎）— step16_q1.php

1〜10 を1行ずつ出力し、最後に合計を表示してください。

期待される合計：55（検算済）

出力例（抜粋）：

1
2
...
10
合計: 55


解答：

<?php

$count = 1;
$sum = 0;

while ($count <= 55){
  echo $count . "\n";
  $sum += $count;
  $count++
}

echo "合計：" . $sum . "\n";

?>

お！提出ありがとうございます。早速コードをチェックしてみますね。

🔍 チェック結果

1. コード上の問題点

ループ条件

while ($count <= 55){

→ 問題文は「1〜10を出力し、合計を表示」でした。
なので、ここは 10 までにすべきです。55 だと「1〜55まで全部出す」ことになります。
ーーーーーーーーーーーーーーーーーーーーーーーーーー
セミコロンの抜け

$count++


→ PHPでは ++ の後にセミコロン ; が必要です。
正しくは：

$count++;

ーーーーーーーーーーーーーーーーーーーーーーーーーー
表記の統一
出力文が

echo "合計：" . $sum . "\n";


と「全角コロン」になっています。もちろん動作には影響しませんが、基本的に半角コロン : を使うのが慣例です。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
問題1の修正版：
<?php

$count = 1;
$sum = 0;

while ($count <= 10){
  echo $count . "\n";
  $sum += $count;
  $count++;
}

echo "合計:" . $sum . "\n";

?>

✅ 採点結果：合格
1〜10 が順に出力される
合計は 55 で正しく計算できている
セミコロン抜けもなく、フォーマットも問題なし

実行結果は以下の通りになるはずです：

1
2
3
4
5
6
7
8
9
10
合計:55

💡 補足ポイント

$count++ のインクリメントがあるおかげで、ループが正しく終了します。
もしこれが抜けていたら「無限ループ」になり、止まらなくなっていました。

今回のように 合計やカウンタをループ内で更新する処理は、実務でもよく使うパターンです（売上集計、ポイント計算など）。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
問題2（break/continue 応用）— step16_q2.php

偶数のみを小さい順に加算し、合計が100を超えた時点で break。
各ステップで 「加算: 値 / 合計: 現在値」 を表示してください。

最後に加算した偶数は 20

終了時の合計は 110

出力例（抜粋）：

加算: 2 / 合計: 2
...
加算: 20 / 合計: 110
しきい値を超えたので終了


解答：

<?php

$i = 1;
$sum = 0;

while (true){
  if ($i %2 == 0){
    $i++;
    continue;
  }
  $sum += $i;
  echo "加算：{$i}/合計：{$sum}\n";

  if ($sum > 100){
    echo "しきい値を超えたので終了\n";
    break;
  }
  $i++
}

?>

コード提出ありがとうございます！👀
じっくり見てみましょう。
🔍 チェック
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
1. 意図とコードのズレ

今回の問題は 「偶数だけを加算し、合計が100を超えたら終了」 でした。

でも今のコードは if ($i % 2 == 0) のときに continue; しているので、
「偶数をスキップして奇数だけ加算」 になっています。💡
→ 条件式を逆にすればOKです。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
2. セミコロン抜け
$i++


ここにセミコロン ; が必要です。

$i++;
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
3. 出力フォーマット

今は：

echo "加算：{$i}/合計：{$sum}\n";


となっていますが、コロンが全角 ： です。
実務では基本半角を推奨します（動作は問題なし）。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
問題2：修正版

<?php

$i = 1;
$sum = 0;

while (true) {
    if ($i % 2 != 0) { 
        $i++;
        continue;
    }

    $sum += $i;
    echo "加算: {$i} / 合計: {$sum}\n";

    if ($sum > 100) {
        echo "しきい値を超えたので終了\n";
        break;
    }

    $i++;
}
?>

素晴らしいです！🎉
コードを丁寧に修正されていて、もうバッチリです。

✅ 採点結果：合格
偶数のみ加算できている
合計が100を超えた時点で break している
実行結果は期待通り以下になります👇

加算: 2 / 合計: 2
加算: 4 / 合計: 6
加算: 6 / 合計: 12
加算: 8 / 合計: 20
加算: 10 / 合計: 30
加算: 12 / 合計: 42
加算: 14 / 合計: 56
加算: 16 / 合計: 72
加算: 18 / 合計: 90
加算: 20 / 合計: 110
しきい値を超えたので終了


検算どおり、20を加算した時点で合計110となり終了します。

💡 学びのポイント
if ($i % 2 != 0) として「奇数ならスキップ」という書き方は、実務でよく使う発想です。
continue の使い所を正しく理解できていますね。
ループ条件を while(true) とし、内部の break で終了条件を制御する方法は、条件駆動ループの基本テクニックです。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

疑問：
すみません。質問です。
continueはどういう意味なんですか？

echo "加算: {$i} / 合計: {$sum}\n";
←このように一気に繋げて書いてもいいのですか？
今までは.を使っていたけれど。

while文は{}の外にi++であったり、sum += $iを書いていますが、そういう方式なんでしょうけど、これは何の意味なのか説明お願いします。
ーーーーーーーーーーーーーーーーーーーーーーーーーーー
ChatGPT:
とても良い質問です！🌱
それぞれ整理して説明しますね。
ーーーーーーーーーーーーーーーーーーーーーーーーーーー
1. continue の意味

意味：「ループの残りの処理をスキップして、次の繰り返しに進む」

今回の例だと：

if ($i % 2 != 0) { 
    $i++;
    continue;
}

→ $i が奇数のときは「この後の $sum += $i; や echo を実行せずに、すぐ次のループへ飛ぶ」
→ だから「奇数はスキップされて、偶数だけ処理される」仕組みになります。

💡 まとめ
break：ループ全体を終了する
continue：その回の処理を途中でやめて「次のループへ進む」

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
2. echo "加算: {$i} / 合計: {$sum}\n"; の書き方について

これは 文字列の中に変数を埋め込む方法 です（文字列展開 と言います）。

ダブルクォーテーション "" の中で {} を使うと、変数を安全に展開できます。

例：

echo "合計は $sum です\n";      / OK（変数は展開される）
echo '合計は $sum です\n';      / NG（シングルクォートでは展開されない）


これまでは：

echo "加算:" . $i . " / 合計:" . $sum . "\n";

と「文字列の連結演算子 .」を使っていました。
どちらも正解で、慣れてくると {$i} のように展開して書くほうがスッキリ見えることが多いです。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

3. while文の中での $i++ や $sum += $i

意味：ループの「状態更新」を外（ループ本体の最後）にまとめて書くスタイルです。

A. 位置の違い
while ($count <= 10) {
    echo $count;
    $sum += $count;
    $count++; / ← ループ本体の最後に書く
}

これは 「処理をした後にカウンタを更新」 するスタイル。
一方で for 文は「初期化・条件・更新」を1行にまとめます：

for ($count = 1; $count <= 10; $count++) {
    echo $count;
    $sum += $count;
}

B. 意味の整理

i++ → カウンタを 1 増やして、次のループ条件を満たすか判定できるようにする

$sum += $i → 「今の値を合計に加算する」という状態の更新
これをやらないと、同じ数値を繰り返し出力するか、無限ループになってしまいます。

✅ まとめ

continue：その回の残り処理をスキップして次のループへ
→ 条件ごとのスキップ処理に便利

echo "{$変数}"：文字列展開。. で連結するのと同じだが、スッキリ書ける

i++ や $sum += $i をループ末尾に書くのは「状態更新をまとめる」方式で、for文と同じ考え方
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

今回の問題2の流れは以下である。

最初に $i と $sum を定義する。
while(true) で無限ループを開始。

if ($i % 2 != 0)
奇数なら → $i++ して continue;
→ つまり「合計には足さずに最初に戻る」。

偶数なら
$sum += $i; で足す
echo で出力する

if ($sum > 100)`
→ ここが「終了ライン」
条件を満たしたら「終了メッセージを出して break」
終了条件に当てはまらなければ 
$i++
→ 次の数に進んでループを続ける

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
問題3（do-while の性質）— step16_q3.php

整数 $n = 5070 の 各桁を下位桁から出力してください（0 7 0 5 の順）。

do { ... } while ($n > 0); を使って、$n が 0 のときでも最低1回は実行されることを確認できる構造にしてください（$n=0 でも1回は処理が走る）。

出力例：

0
7
0
5


解答：


問題3の解説

まず、出力したい数字をnに入れる。
これをどう出力するかをdo whileでやっていく。
こんかいは逆順で数字を出していく。その為に1の位から数字を出していく。
$digit = $n % 10;←は5070が入っているnを10で割って余りを見ていく。
その余りが1の位であるため、
echo $digit . "\n"; ←その出た1の位の数を出力する。
次に進んでいくが、5070を10で割って1の位を出したので、次は507という数字で始めなければいけない。 
その為に 
$n = intdiv($n, 10);←桁を削る作業をする。 
そして、いつまで続けるかの条件を示す必要があるが、それが
} while ($n > 0);←で $n が 0 より大きい間は続ける＝数字が0でなくなるまでやるという意味。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー





































-ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

了解しました！✨
ステップ16「while / do-while」を始めましょう。
流れはいつものとおり 例文コード → なぜ重要か解説 → 練習問題 → 最終テスト → 応用問題 で進めます。

🔹 Step16：while / do-while
1. 基本の書き方（例文コード）

<?php
// while文の例
$count = 1;

while ($count <= 5) {
    echo $count . "回目のループです\n";
    $count++;
}


// do-while文の例
$number = 6;

do {
    echo "do-whileは条件判定の前に必ず1回実行されます。現在の値: $number\n";
    $number++;
} while ($number <= 5);
?>


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

2. 学習の意味・重要性

while文
条件を満たしている間、処理を繰り返す。繰り返し回数が不明なときに有効。
例：ユーザーが正しいパスワードを入力するまで繰り返す。

do-while文
条件判定を後に行うため、最低1回は必ず実行される。
例：メニュー画面を最低1回は表示 → 「終了」が選ばれるまで繰り返す。

メリット
無限ループや条件付き繰り返しを実現できる
実務では「入力チェック」や「ユーザー操作の待機処理」で使われる
for文との違いを理解することで、適材適所の使い分けが可能になる

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

3. 練習問題（あなたに解いてもらう問題）

📌 問題1
1から10までの偶数を while文 を使って出力してください。
（ヒント：変数の初期値をどうするか、カウントの増やし方に注意してください）

<?php

$i = 1;

while($i <= 10){
    if($i %2 = 0){
        echo "{$i}\n"; 
    }
}

?>

いいですね！実際に while を使えていて、条件分岐も書けています👏
ただし、細かい 修正ポイントが2つ あります。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
❌ 修正点

・比較演算子の誤り

if($i %2 = 0){

これは 代入演算子 = を使ってしまっています。
→ 比較演算子 == を使う必要があります。
正しくは：

if ($i % 2 == 0) {



・カウンタのインクリメント忘れ
while ループの中で $i++ を書いていないので、無限ループになってしまいます。
→ 各ループごとに $i を増やしましょう。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

問題1の修正版：

<?php

$i = 1;

while($i <= 10){
    if($i %2 == 0){
        echo "{$i}\n"; 
    }
    $i++;
}

?>

💮 完璧です！
$i % 2 == 0 で偶数判定できている
$i++ でカウンタを正しく増やして無限ループを防いでいる
実行すると 2, 4, 6, 8, 10 が出力される

とても良いコードになりました 👏✨

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

📌 問題2
do-while文を使って、変数 $x の値を 1 から始めて、5以下の間「xの値は: ○」と表示してください。

ファイル名は step16_while.php にしてください。

👉 できたらコードを貼ってください。私は先生としてチェックし、正誤とフィードバックをします。

<?php

$x = 1;

do {
    echo"xの値は{$x}\n";
    $x++;
}while($x <= 5);

?>

💯 素晴らしいです！
あなたの do-while 文はしっかり書けています 👍
必ず1回実行される do-while の特性を正しく使えている
$x++ でインクリメントしているので無限ループにならない

出力も指定通り

✅ 実行結果
xの値は1
xの値は2
xの値は3
xの値は4
xの値は5

完璧です！👏✨

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

📌 次のステップ
ここで 最終テスト（集大成問題） に進みましょう。

🔹 最終問題

while または do-while を使って、
1〜20までの数字のうち、3の倍数だけを表示するプログラム を作ってください。

👉 ファイル名は step16_final.php にしてください。

書けたらコードを貼ってください。先生として採点します！


<?php

$number = 1;

while($number <= 20){
    if(%3 == 0){
        echo"{$number}\n";
    }
    number++;
}

?>

❌ 修正ポイント

1,
if(%3 == 0){

%3 の前に変数名 $number が抜けています。
→ 正しくは $number % 3 == 0 です。

2,
number++;

$ が抜けています。
→ 正しくは $number++ です。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

最終問題修正版while文:

<?php

$number = 1;

while($number <= 20){
    if($number %3 == 0){
        echo"{$number}\n";
    }
    $number++;
}

?>

👏 いいですね！しっかり修正できています。

$number % 3 == 0 で3の倍数を判定
$number++ でカウンタを進めて無限ループ回避
1から20までの範囲で判定して出力

✅ 実行結果
3
6
9
12
15
18


完璧に動きます！💮

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

<?php

$number = 1;

do{
    if($number %3 == 0){
        echo "{$number}\n";
    }
    $number++;
}while($number <= 20);

?>

❌ 修正ポイント

こちらはほぼ正解ですが、可読性を上げるためにスペースを整えた方が良いです。
（動作は問題ありません）
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

最終問題修正版do while文:

<?php

$number = 1;

do{
    if($number %3 == 0){
        echo "{$number}\n";
    }
    $number++;
}while($number <= 20);

?>

💮 素晴らしいです！

先ほどの while に続いて、do-while 版も完璧に書けています。

do { ... } while (...); の構文を正しく使えている
$number % 3 == 0 で 3 の倍数を判定
$number++ でカウンタを進めているので無限ループなし
1から20までの範囲で正しく出力

✅ 実行結果
3
6
9
12
15
18

これで Step16（while / do-while）の最終テストは完全合格 です 🎉✨

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

🔹 応用

ユーザーに数字を入力してもらい（例：10）、その数字までの偶数を while で出力するプログラムを作成してください。

例：

<?php

echo "数字を入力してください: ";
$limit = (int) fgets(STDIN);  / 標準入力から数値を取得

$i = 1;

while ($i <= $limit) {
    if ($i % 2 == 0) {
        echo $i . "\n";
    }
    $i++;
}

?>


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

🔹 応用問題②（新しい問題）

ユーザーに数字を入力してもらい（例：15）、その数字までの「3の倍数」だけを do-while で出力するプログラムを作ってください。

<?php

echo "数字を入力してください: ";
$limit = (int) fgets(STDIN);

$i = 1;

while ($i <= $limit) {
    if ($i % 3 == 0) {
        echo "{$i}\n";
    }
    $i++;
}

?>

<?php

$limit = (int) fgets(STDIN);

$i = 1;

do{
    if($i % 3 == 0){
        echo"{$i}\n";
    }
    $i++;
}while($i <= $limit);

?>

💮 完璧です！

fgets(STDIN) で入力を受け取って (int) で数値に変換できている
do { ... } while (...); 構文を正しく書けている
$i % 3 == 0 で 3 の倍数判定
$i++ でカウンタを進めて無限ループを防止

✅ 実行例

入力: 15
出力:

3
6
9
12
15


これで 応用問題②（do-while版）も合格 です 🎉✨