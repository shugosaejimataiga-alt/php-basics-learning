🧩 フェーズ8：セッションとCookie
Step33：セッションを使った簡易ログイン


🔍 学習目的と意義

このステップでは、「セッション（session）」を使ってログイン機能の基礎を理解します。
Webアプリでは「ユーザーがログインした状態を維持する」仕組みが欠かせません。

PHPのセッションはそれを実現する最も基本的な方法です。
セッションはサーバー側でデータを保持し、ユーザーごとに「一時的な保存領域」を作ります。
Cookieと違い、データがサーバーに保存されるため安全性が高いのが特徴です。



✅ 学ぶポイント

session_start() の意味
→ セッションを開始し、PHPがユーザーを識別できるようにする。

$_SESSION 連想配列の使い方
→ $_SESSION["key"] = "value"; でデータを保存できる。

セッションを使って「ログイン済みかどうか」を判定する。



💡 例文コード（step33_session_login.php）
<?php
session_start(); // セッションを開始（最初に必ず書く）

// ユーザー名とパスワードを仮に設定
$correct_user = "kiryu";
$correct_pass = "dragon";

// フォーム送信があったかを確認
if ($_SERVER["REQUEST_METHOD"] === "POST") {
  $user = $_POST["username"];
  $pass = $_POST["password"];

  // 入力チェック
  if ($user === $correct_user && $pass === $correct_pass) {
    $_SESSION["login_user"] = $user; // ログイン情報をセッションに保存
    echo "ログイン成功！ようこそ、{$user}さん<br>";
    echo "<a href='step33_mypage.php'>マイページへ</a>";
  } else {
    echo "ユーザー名またはパスワードが間違っています。";
  }
} else {
?>
  <!-- ログインフォーム -->
  <form method="post">
    ユーザー名：<input type="text" name="username"><br>
    パスワード：<input type="password" name="password"><br>
    <input type="submit" value="ログイン">
  </form>
<?php
}
?>



💡 次に：マイページ（step33_mypage.php）
<?php
session_start(); // セッションを開始

if (isset($_SESSION["login_user"])) {
  echo "現在ログイン中のユーザー：" . $_SESSION["login_user"] . "<br>";
  echo "<a href='step33_logout.php'>ログアウト</a>";
} else {
  echo "ログインしていません。<a href='step33_session_login.php'>ログインページへ戻る</a>";
}
?>



💡 ログアウト処理（step33_logout.php）
<?php
session_start();
session_unset();  // セッション変数をすべて削除
session_destroy(); // セッション自体を破棄
echo "ログアウトしました。<a href='step33_session_login.php'>ログインページへ戻る</a>";
?>



🧠 理解ポイントの整理

session_start() はすべてのページで最初に必須。
ログイン状態は $_SESSION["login_user"] で判定。
session_unset() と session_destroy() で完全にログアウト。
セッションはブラウザを閉じると基本的に破棄される（自動ログアウト）。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

🧩 練習問題①

📘 問題：
次の要件を満たす PHP ファイル step33_test_login.php を作成してください。

ログイン名：testuser

パスワード：1234

ログイン成功時は「ようこそ testuser さん！」と表示

ログイン失敗時は「ログイン情報が正しくありません」と表示

$_SESSION["user_name"] にユーザー名を保存すること

あなたがコードを書いたら、私は 正誤チェック と なぜそうなるかの解説 を行います。
書けたら「できました」と送ってください。

<?php

session_start();

correct_user = "testuser";
correct_pass = 1234;

if ($_SERVER["REQUEST_METHOD"] === "POST") {
  $user = $_POST["username"];
  $pass = $_POST["password"];

  if ($user === $correct_user && $pass === $correct_pass) {
    $_SESSION["user_name"] = $user;
    echo "ようこそ{$user}さん！\n";
  } else {
    echo "ログイン情報が正しくありません\n";
  }
}

?>

とても良いです。
あなたのコードはしっかり書けていますが、2つだけ修正が必要です。
（PHPは細かい文法ミスに厳しいので、ここを正確に理解しておきましょう。）

❌ 今のコードの問題点

1️⃣ $ の意味

PHPでは変数を表すときに必ず $ が必要です。
例えば：

$name = "桐生";

この $name は変数。
もし $ がないと PHP は「定数」として扱おうとします（未定義ならエラーになります）。


2️⃣ === と == の違い

=== は「型も中身も一致」
== は「中身だけ一致」

今回 $pass はフォームから送られてくるとき 文字列型（"1234"） になります。
一方 $correct_pass = 1234; は数値（int）です。

したがって：

=== だと型が違うため「不一致」になる。
== なら値が同じなので「一致」とみなされる。

👉 今回は == が正解です。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

練習問題修正版：

<?php

session_start();

$correct_user = "testuser";
$correct_pass = 1234;

if ($_SERVER["REQUEST_METHOD"] === "POST") {
  $user = $_POST["username"];
  $pass = $_POST["password"];

  if ($user === $correct_user && $pass == $correct_pass) {
    $_SESSION["user_name"] = $user;
    echo "ようこそ{$user}さん！\n";
  } else {
    echo "ログイン情報が正しくありません\n";
  }
}

?>

とても良いです。このコードは、もう完全に正しい動きをします。

一行ずつ、何をしているのかを丁寧に説明しますね。



まず最初の

session_start();

これはセッション機能を使う宣言です。
ブラウザごとに「一時的なデータ領域（サーバー側）」を用意し、
そのユーザーを識別できるようにします。
これがないと $_SESSION は使えません。



次に、

$correct_user = "testuser";
$correct_pass = 1234;

これはログインの正しい情報をあらかじめ設定しています。
実際のシステムではデータベースに保存されますが、今は固定で定義しているだけです。



次の部分

if ($_SERVER["REQUEST_METHOD"] === "POST") {

は、「フォームからPOST送信されたときだけ中の処理を動かす」という条件です。
つまり、初めてページを開いた段階では何もしません。
フォームを送信して初めてこの中が実行されます。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

そもそも、ページを開く行為＝リクエストがある。
PHPは上から順である。
リクエストには2種類あってGETとPOSTである。

なるほど。GETは何かを見たりする行為の元で、一般的にそこまで機密性が高くない行為。ページを開くであったり。
POSTはGETより機密性の高い行為になりやすく、ログインのフォーム＝一般的にユーザー名やパスワードを送る。

だから、if ($_SERVER["REQUEST_METHOD"] === "POST") ←POSTの種類のリクエストが送られたらというif文を付けてあるという事ですね。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

続いて

$user = $_POST["username"];
$pass = $_POST["password"];

ここでフォームに入力されたユーザー名とパスワードを受け取ります。
POSTはHTTP通信の本文に入って送られるため、URLに値が見えません。
それをPHPが自動で $_POST 配列にまとめてくれます。



次に

if ($user === $correct_user && $pass == $correct_pass) {

で「正しいユーザー名とパスワードか」を判定しています。
ここでは === で文字列の完全一致を、== で数値の一致を見ています。
パスワードはフォームから文字列で送られるため、型の違いを許容する == が適しています。

もし一致していた場合、

$_SESSION["user_name"] = $user;

この行でセッションにユーザー名を保存します。
つまり、サーバーの中に「このブラウザは testuser としてログイン中」と記録されます。



その後、

echo "ようこそ{$user}さん！\n";

と表示して歓迎メッセージを出します。

一致しなかった場合は

echo "ログイン情報が正しくありません\n";

というメッセージを表示します。



このコードの動作をまとめるとこうなります。
フォームで「testuser」「1234」と送信された場合だけ
$_SESSION["user_name"] に "testuser" という文字列が保存されます。
これにより次のページでもログイン情報を維持できるようになります。

ここまで理解できていれば、あなたは「セッションを使ったログインの基礎」を完全にクリアしています。
次の確認です。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

このあと step33_mypage.php を開くとき、
なぜ $_SESSION["user_name"] を使うだけで「ログイン中のユーザー名」が分かると思いますか？


疑問：
まったくわかりません


ChatGPT:
とても正直でいいです。
では、まったくのゼロから、**「なぜ別のページでもログインが分かるのか」**を、
ゆっくり根本から説明しますね。



🧠 スタート地点：「普通の変数との違い」

PHPで普通に変数を使うとき、たとえばこう書きます。

$name = "kiryu";
echo $name;

この $name は、その1つのPHPファイルの中でしか使えません。
別のファイルを開いた瞬間、すべて消えます。
ページを移動すると変数はリセットされる、これが普通の動作です。



💡 ここで出てくる「セッション（session）」の役割

セッションとは、「ページを移動しても残る特別な変数」です。

普通の変数はページが変わると消えますが、
セッション変数はサーバーに保存されるので、ページをまたいでも残ります。



🧩 どうやって同じ人だとわかるのか

あなたが最初にログインページを開いたとき、
PHPは session_start() で「セッションID」という秘密の番号を作ります。

その番号を、ブラウザの中の「Cookie」に自動で保存します。
たとえば「あなた＝ID 12345」という感じです。

次に別のページ（マイページなど）を開くとき、
ブラウザは自動的に「ID 12345ですよ」とPHPに伝えます。

PHPはそのIDを見て、「あ、この人は前にログインした testuser さんだ」と判断します。

その結果、$_SESSION["user_name"] に保存していた "testuser" を取り出せるのです。



🔍 たとえるなら…

セッションとは、「受付番号つきのロッカー」のようなものです。
ロッカー番号（セッションID）が、あなたのブラウザに渡されます。
サーバー側（ロッカー室）には、その番号のロッカーにデータ（ユーザー名など）が入っています。
あなたが別のページを開いても、同じ番号のロッカーを使うので、中のデータを取り出せるのです。



🧩 つまり、step33_mypage.php でこう書ける理由
if (isset($_SESSION["user_name"])) {
  echo "現在ログイン中：" . $_SESSION["user_name"];
}

これは、「ロッカーの中に user_name という荷物（データ）があるか？」を確認しています。
ある場合は、まだログイン状態が続いている、ということになります。

ここまでで大枠がつかめましたか？


だから、一般的にはPHPの変数はそのファイルだけでしか使えないけれど、session変数はページをま
たいでも残るという特性があります。だから、ログインページを開いたときのsession変数をマイペー
ジの時使うから、if文でsession変数があるかを確認しているという事です。


ChatGPT:
その理解、完璧です。

あなたの言ったとおりです。
PHPの普通の変数は、1つのページ（ファイル）内で処理が終わると同時に消えます。
しかし、セッション変数はサーバーの中に保管され、ページをまたいでも残る特性を持っています。

だからこそ、
ログインページでセッション変数 $_SESSION["user_name"] に「testuser」を保存する。

マイページで $_SESSION["user_name"] が存在するかを if 文で確認する。

この流れによって「ログインしている人かどうか」を判断できるわけです。

つまり、PHPのセッションとは
「ログイン状態を一時的にサーバーに預ける仕組み」
という理解ができています。

あなたの説明は完全に正しいです。

ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

では、Step33：セッションを使った簡易ログインの最終テスト に進みましょう。
ここでは、今まで学んだ内容（セッション・POST・条件分岐）をすべて組み合わせます。

🧩 最終テスト問題
🎯 目的

簡易ログイン → マイページ → ログアウトまでの一連の流れを、3ファイルで構成してください。

🧱 要件
① step33_login.php

ユーザー名とパスワードのフォームを用意する

正しい組み合わせは：
ユーザー名：akira
パスワード：9999

ログイン成功時：
$_SESSION["user"] にユーザー名を保存
「ログイン成功！マイページへ」へのリンクを表示

ログイン失敗時：
「ユーザー名またはパスワードが違います」と表示

② step33_mypage.php

セッションがあるときは：
「ようこそ〇〇さん！」と表示
「ログアウト」リンクを表示（step33_logout.phpへ）

セッションがないときは：
「ログインしていません」と表示し、ログインページへのリンクを表示

③ step33_logout.php

session_start()

session_unset() と session_destroy() を使ってセッションを完全削除

「ログアウトしました」＋ログインページへのリンクを表示

✅ 条件

各ファイルの最初に session_start(); を必ず書くこと。

文字コードは UTF-8。

出力は日本語でOK。

作成が終わったら、まず step33_login.php のコードをここに貼ってください。
（その後にマイページ → ログアウトの順に確認していきます）

<?php

session_start();

$correct_user = "akira";
$correct_pass = 9999;

if ($_SERVER[REQUEST_METHOD]==="POST") {
  $user = $_POST["username"];
  $pass = $_POST["password"];

  if($user === $correct_user && $pass == $correct_pass) {
    $_SESSION["user"] = $user;
    echo "ログイン成功！マイページへ\n";
    echo "<a href='step33_mypage.php'>マイページへ</a>";
  } else {
    "ユーザー名またはパスワードが違います\n";
  }
}

?>

<?php

session_start();

if (isset($_SESSION["user"])) {
  echo "ようこそ" . $_SESSION["user"] . "さん！\n";
  echo "<a href='step33_logout.php'>ログアウト</a>";
} else {
  echo "ログインしていません\n";
  echo "<a href='step33_session_login.php'>ログインページへ戻る</a>";
}

?>


<?php
session_start();

session_unset();

session_destroy();

echo "ログアウトしました。<a href='step33_session_login.php'>ログインページへ戻る</a>";

?>


🟢 全体としての評価

あなたのコードは流れも構造も非常に正しいです。
ログイン → マイページ → ログアウトの基本の流れをきちんと理解しています。
修正はほんの数箇所だけで、どれも文法レベルの細かい点です。

🔧 修正点一覧（わかりやすく分解）
① $_SERVER[REQUEST_METHOD] の書き方

❌ 今の書き方：

if ($_SERVER[REQUEST_METHOD] === "POST") {

✅ 正しい書き方：

if ($_SERVER["REQUEST_METHOD"] === "POST") {

📝理由：
PHPの $_SERVER は「連想配列」です。
配列のキー（"REQUEST_METHOD"）は文字列なので、必ず ダブルクォーテーション（""）で囲む必要があります。
囲まないと PHP は「定数」と誤認してエラーになります。



② エラーメッセージの echo の付け忘れ

❌ 今の書き方：

"ユーザー名またはパスワードが違います\n";

✅ 正しい書き方：

echo "ユーザー名またはパスワードが違います\n";

📝理由：
ただ文字列を書くと何も表示されません。
画面に出したいときは echo が必要です。



③ フォームを最初に表示する処理が抜けている

🟡 今の状態では、フォームを送る機能（$_POSTを受け取る）だけで、
最初に開いたとき（GET時）にフォームそのものが表示されません。

✅ 対応方法：
else { } の中にフォームのHTMLを書く。
つまり「まだPOSTされていないとき」はフォームを表示するようにします。



④ ファイル名の整合性

🟡 マイページ や ログアウト のリンクにあるファイル名が、
一部 step33_session_login.php になっています。

✅ 修正：
全部 step33_login.php に統一しましょう。



⑤ HTMLの改行は <br> を使う

🟡 \n はHTMLでは改行されません。
画面に見やすく出したい場合は：

echo "ログイン成功！<br>";

のように <br> を使うと良いです。



🧠 修正の要点だけまとめると：

"REQUEST_METHOD" はダブルクォーテーションで囲む。

エラーメッセージには echo をつける。

POSTで送られていないとき（最初のアクセス時）はフォームを表示する。

リンク先のファイル名を全体で統一する。

改行は \n ではなく <br> を使う。

この5点を直せば、あなたのログイン機能は完全動作になります。
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

最終問題修正版：

<?php

session_start();

$correct_user = "akira";
$correct_pass = 9999;

if ($_SERVER["REQUEST_METHOD"]==="POST") {
  $user = $_POST["username"];
  $pass = $_POST["password"];

  if($user === $correct_user && $pass == $correct_pass) {
    $_SESSION["user"] = $user;
    echo "ログイン成功！<br>マイページへ<br>";
    echo "<a href='step33_mypage.php'>マイページへ</a>";
  } else {
    echo "ユーザー名またはパスワードが違います<br>";
  }
} else {
?>
  <!-- ログインフォーム -->
  <form method="post">
    ユーザー名：<input type="text" name="username"><br>
    パスワード：<input type="password" name="password"><br>
    <input type="submit" value="ログイン">
  </form>
<?php
}
?>


<?php

session_start();

if (isset($_SESSION["user"])) {
  echo "ようこそ " . $_SESSION["user"] . " さん！<br>";
  echo "<a href='step33_logout.php'>ログアウト</a>";
} else {
  echo "ログインしていません";
  echo "<a href='step33_login.php'>ログインページへ戻る</a>";
}

?>


<?php
session_start();

session_unset();

session_destroy();

echo "ログアウトしました。<br><a href='step33_login.php'>ログインページへ戻る</a>";

?>


完璧です。
このコードは構文的にも動作的にも正しく、セッションによるログイン〜マイページ〜ログアウトの流れが完全に成立しています。

ただし、確認のために1点だけ実務的な補足をします。



✅ 構造としての最終チェック


step33_login.php

session_start() が最初にある → OK

$_SERVER["REQUEST_METHOD"] の判定も正しい → OK

ログイン成功時にセッション変数をセット → OK

最初のアクセスではフォームを表示 → OK


step33_mypage.php

セッションを開始して、isset($_SESSION["user"]) でログイン状態を確認 → OK

ログアウトリンクも設置 → OK


step33_logout.php

セッションの破棄処理が順序通り（start → unset → destroy） → OK

ログインページへ戻るリンク → OK



💡 実務的な補足（開発者の観点）

本番環境や実務では、
HTML構造を分離（header.php / footer.php）
出力前に session_start() を必ず最上部に記述
攻撃防止のため、ログイン情報にはハッシュ化（例：password_hash()）を使用

これらを追加するとより安全で堅牢な実装になります。



🎯 評価

✅ 構文：完全正解
✅ セッション管理：正確
✅ POST判定とフォーム：完璧
✅ 動作の流れ：問題なし

Step33（セッションを使った簡易ログイン）合格です！🎉
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー




リクエスト行為にはGETとPOSTがあるというのは理解しました。次にSERVERはそれらの送られてきた過程の情報を記すという機能であったと思います。
セッションはサーバー側に保存で短期であり、ブラウザを閉じると削除される。Cookieの中の「セッションID」で誰のものか識別する。使い道：ログイン中のユーザーの情報、一時的な状態保持など。
Cookieはブラウザ側に保存され長期である（期間を指定できる）。使い道：ログイン状態の記憶（長期間）
